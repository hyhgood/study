(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{207:function(t,e,a){"use strict";a.r(e);var n=a(0),r=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"dom-diff算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dom-diff算法","aria-hidden":"true"}},[t._v("#")]),t._v(" DOM diff算法")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdn.net/20180717182348969",alt:""}}),t._v("\nDIFF算法在执行时有三个维度，分别是Tree DIFF、Component DIFF和Element DIFF，执行时按顺序依次执行，它们的差异仅仅因为DIFF粒度不同、执行先后顺序不同。")]),t._v(" "),a("h2",{attrs:{id:"tree-diff"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tree-diff","aria-hidden":"true"}},[t._v("#")]),t._v(" Tree DIFF")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdn.net/2018071718264787",alt:""}}),t._v("\nTree DIFF是对树的每一层进行遍历，如果某组件不存在了，则会直接销毁。如图所示，左边是旧属，右边是新属，第一层是R组件，一模一样，不会发生变化；第二层进入Component DIFF，同一类型组件继续比较下去，发现A组件没有，所以直接删掉A、B、C组件；继续第三层，重新创建A、B、C组件。")]),t._v(" "),a("h2",{attrs:{id:"component-diff"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#component-diff","aria-hidden":"true"}},[t._v("#")]),t._v(" Component DIFF")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdn.net/20180717182802621",alt:""}}),t._v("\n如图所示，第一层遍历完，进行第二层遍历时，D和G组件是不同类型的组件，不同类型组件直接进行替换，将D删掉，再将G重建。")]),t._v(" "),a("h2",{attrs:{id:"element-diff"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-diff","aria-hidden":"true"}},[t._v("#")]),t._v(" Element DIFF")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdn.net/20180717182842111",alt:""}}),t._v("\nElement DIFF紧接着以上统一类型组件继续比较下去，常见类型就是列表。同一个列表由旧变新有三种行为，插入、移动和删除，它的比较策略是对于每一个列表指定key，先将所有列表遍历一遍，确定要新增和删除的，再确定需要移动的。如图所示，第一步将D删掉，第二步增加E，再次执行时A和B只需要移动位置即可。")])])}],!1,null,null,null);e.default=r.exports}}]);