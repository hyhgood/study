(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{207:function(e,t,n){"use strict";n.r(t);var a=n(0),r=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[n("h2",{attrs:{id:"传统diff算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#传统diff算法","aria-hidden":"true"}},[e._v("#")]),e._v(" 传统diff算法")]),e._v(" "),n("p",[e._v("计算一棵树形结构转换为另一棵树形结构需要最少步骤，如果使用传统的diff算法通过循环递归遍历节点进行对比，其复杂度要达到O(n^3)，其中n是节点总数，效率十分低下，假设我们要展示1000个节点，那么我们就要依次执行上十亿次的比较。\n下面附上一则简单的传统diff算法：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('let result = [];\n// 比较叶子节点\nconst diffLeafs = function (beforeLeaf, afterLeaf) {\n    // 获取较大节点树的长度\n    let count = Math.max(beforeLeaf.children.length, afterLeaf.children.length);\n    // 循环遍历\n    for (let i = 0; i < count; i++) {\n        const beforeTag = beforeLeaf.children[i];\n        const afterTag = afterLeaf.children[i];\n        // 添加 afterTag 节点\n        if (beforeTag === undefined) {\n            result.push({ type: "add", element: afterTag });\n            // 删除 beforeTag 节点\n        } else if (afterTag === undefined) {\n            result.push({ type: "remove", element: beforeTag });\n            // 节点名改变时，删除 beforeTag 节点，添加 afterTag 节点\n        } else if (beforeTag.tagName !== afterTag.tagName) {\n            result.push({ type: "remove", element: beforeTag });\n            result.push({ type: "add", element: afterTag });\n            // 节点不变而内容改变时，改变节点\n        } else if (beforeTag.innerHTML !== afterTag.innerHTML) {\n            if (beforeTag.children.length === 0) {\n                result.push({\n                    type: "changed",\n                    beforeElement: beforeTag,\n                    afterElement: afterTag,\n                    html: afterTag.innerHTML\n                });\n            } else {\n                // 递归比较\n                diffLeafs(beforeTag, afterTag);\n            }\n        }\n    }\n    return result;\n}\n')])])]),n("h2",{attrs:{id:"dom-diff算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#dom-diff算法","aria-hidden":"true"}},[e._v("#")]),e._v(" DOM diff算法")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://img-blog.csdn.net/20180717182348969",alt:""}}),e._v("\nDIFF算法在执行时有三个维度，分别是Tree DIFF、Component DIFF和Element DIFF，执行时按顺序依次执行，它们的差异仅仅因为DIFF粒度不同、执行先后顺序不同。")]),e._v(" "),n("ul",[n("li",[e._v("Tree DIFF")])]),e._v(" "),n("p",[n("img",{attrs:{src:"https://img-blog.csdn.net/2018071718264787",alt:""}})]),e._v(" "),n("p",[e._v("Tree DIFF是对树的每一层进行遍历，如果某组件不存在了，则会直接销毁。如图所示，左边是旧属，右边是新属，第一层是R组件，一模一样，不会发生变化；第二层进入Component DIFF，同一类型组件继续比较下去，发现A组件没有，所以直接删掉A、B、C组件；继续第三层，重新创建A、B、C组件。")]),e._v(" "),n("ul",[n("li",[e._v("Component DIFF")])]),e._v(" "),n("p",[n("img",{attrs:{src:"https://img-blog.csdn.net/20180717182802621",alt:""}})]),e._v(" "),n("p",[e._v("如图所示，第一层遍历完，进行第二层遍历时，D和G组件是不同类型的组件，不同类型组件直接进行替换，将D删掉，再将G重建。")]),e._v(" "),n("ul",[n("li",[e._v("Element DIFF")])]),e._v(" "),n("p",[n("img",{attrs:{src:"https://img-blog.csdn.net/20180717182842111",alt:""}})]),e._v(" "),n("p",[e._v("Element DIFF紧接着以上统一类型组件继续比较下去，常见类型就是列表。同一个列表由旧变新有三种行为，插入、移动和删除，它的比较策略是对于每一个列表指定key，先将所有列表遍历一遍，确定要新增和删除的，再确定需要移动的。如图所示，第一步将D删掉，第二步增加E，再次执行时A和B只需要移动位置即可。")]),e._v(" "),n("ul",[n("li",[e._v("总结")])]),e._v(" "),n("p",[n("img",{attrs:{src:"https://images2018.cnblogs.com/blog/998023/201805/998023-20180519213134497-676744027.png",alt:""}})])])}],!1,null,null,null);t.default=r.exports}}]);